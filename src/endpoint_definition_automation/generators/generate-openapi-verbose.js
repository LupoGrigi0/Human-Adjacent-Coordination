#!/usr/bin/env node
/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  OPENAPI-VERBOSE.JSON GENERATOR                                           â•‘
 * â•‘  Generates verbose OpenAPI spec with x-hacs-tools for static website      â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Usage: node generate-openapi-verbose.js [--output path/to/openapi-verbose.json]
 *
 * This generates the FULL verbose OpenAPI spec including x-hacs-tools with:
 *   - Full descriptions
 *   - Error codes and recovery instructions
 *   - Examples
 *   - Related endpoints
 *   - Notes
 *
 * Output goes to public/docs/openapi-verbose.json for the static website.
 * The terse version (openapi.json) is generated by generate-openapi.js.
 *
 * @author Axiom (refactored from generate-openapi.js)
 * @created 2026-01-05
 */

import { readdir, readFile, writeFile, mkdir } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { SHARED_CONFIG } from '../shared-config.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  scanDirs: SHARED_CONFIG.scanDirs,
  // Output to public/docs for static website
  defaultOutput: join(SHARED_CONFIG.repoRoot, 'public', 'docs', 'openapi-verbose.json'),
  openapi: {
    version: '3.1.1',
    info: {
      title: 'HACS Coordination API (Verbose)',
      description: 'Human-Adjacent Coordination System - Full API Documentation with examples, errors, and recovery guidance',
      version: '2.0.0',
      contact: {
        name: 'HACS Team',
        url: 'https://github.com/LupoGrigi0/Human-Adjacent-Coordination'
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT'
      }
    },
    servers: [
      {
        url: 'https://smoothcurves.nexus',
        description: 'Production HACS Server'
      }
    ]
  }
};

// ============================================================================
// PARSER (same as generate-openapi.js)
// ============================================================================

function parseEndpointBlock(block) {
  const endpoint = {
    tool: null,
    version: null,
    since: null,
    category: null,
    status: null,
    visibility: 'external',
    description: '',
    params: [],
    returns: [],
    permissions: null,
    rateLimit: null,
    errors: [],
    examples: [],
    related: [],
    notes: [],
    needsClarification: []
  };

  const lines = block.split('\n');
  let currentSection = null;
  let currentParam = null;
  let currentError = null;
  let currentExample = null;
  let descriptionLines = [];
  let sourceLines = [];
  let recoverLines = [];
  let exampleJsonLines = [];

  const SECTION_HEADERS = ['DESCRIPTION', 'PARAMETERS', 'RETURNS', 'PERMISSIONS & LIMITS',
                           'ERRORS & RECOVERY', 'EXAMPLES', 'RELATED', 'NOTES'];

  const isSectionHeader = (line) => {
    return SECTION_HEADERS.some(h => line === h || line.startsWith(h));
  };

  const finalizeCurrentContent = () => {
    if (currentParam && sourceLines.length > 0) {
      currentParam.source = sourceLines.join(' ').trim();
      sourceLines = [];
    }
    if (currentError && recoverLines.length > 0) {
      currentError.recover = recoverLines.join(' ').trim();
      recoverLines = [];
    }
    if (currentExample && exampleJsonLines.length > 0) {
      currentExample.json = exampleJsonLines.join('\n').trim();
      exampleJsonLines = [];
    }
  };

  for (const line of lines) {
    const trimmed = line.replace(/^\s*\*\s?/, '').trim();
    if (trimmed.match(/^[â”€â”Œâ”â””â”˜â”‚â•â•”â•—â•šâ•â•‘]+$/) || trimmed === '') continue;
    if (trimmed.startsWith('â”‚') || trimmed.endsWith('â”‚')) continue;

    if (isSectionHeader(trimmed)) {
      finalizeCurrentContent();
      currentSection = trimmed.toLowerCase().replace(/ & /g, '_').replace(/ /g, '_');
      currentParam = null;
      currentError = null;
      currentExample = null;
      continue;
    }

    if (trimmed.startsWith('@tool ')) {
      endpoint.tool = trimmed.replace('@tool ', '').trim();
    } else if (trimmed.startsWith('@template-version ')) {
      // Skip
    } else if (trimmed.startsWith('@version ')) {
      endpoint.version = trimmed.replace('@version ', '').trim();
    } else if (trimmed.startsWith('@since ')) {
      endpoint.since = trimmed.replace('@since ', '').trim();
    } else if (trimmed.startsWith('@category ')) {
      endpoint.category = trimmed.replace('@category ', '').trim();
    } else if (trimmed.startsWith('@status ')) {
      endpoint.status = trimmed.replace('@status ', '').trim();
    } else if (trimmed.startsWith('@visibility ')) {
      endpoint.visibility = trimmed.replace('@visibility ', '').trim();
    } else if (trimmed.startsWith('@description')) {
      finalizeCurrentContent();
      currentSection = 'description';
    } else if (trimmed.startsWith('@param ')) {
      finalizeCurrentContent();
      currentSection = 'param';
      const paramMatch = trimmed.match(/@param \{([^}]+)\}\s*(\[?[\w.]+\]?=?[^\s]*)\s*-\s*(.+)/);
      if (paramMatch) {
        const isOptional = paramMatch[2].startsWith('[');
        const paramName = paramMatch[2].replace(/[\[\]]/g, '').split('=')[0];
        const defaultMatch = paramMatch[2].match(/=([^\]]+)/);
        currentParam = {
          name: paramName,
          type: paramMatch[1],
          description: paramMatch[3].replace(/\[(required|optional)\]/i, '').trim(),
          required: !isOptional,
          default: defaultMatch ? defaultMatch[1] : undefined,
          source: null,
          enum: null
        };
        endpoint.params.push(currentParam);
        sourceLines = [];
      }
    } else if (trimmed.startsWith('@source ')) {
      sourceLines = [trimmed.replace('@source ', '').trim()];
    } else if (trimmed.startsWith('@default ')) {
      if (currentParam) currentParam.default = trimmed.replace('@default ', '').trim();
    } else if (trimmed.startsWith('@enum ')) {
      if (currentParam) currentParam.enum = trimmed.replace('@enum ', '').trim().split('|').map(s => s.trim());
    } else if (trimmed.startsWith('@validate ')) {
      if (currentParam) currentParam.validate = trimmed.replace('@validate ', '').trim();
    } else if (trimmed.startsWith('@returns ')) {
      currentSection = 'returns';
      const returnMatch = trimmed.match(/@returns \{([^}]+)\}\s*(\S+)\s*-\s*(.+)/);
      if (returnMatch) {
        endpoint.returns.push({
          type: returnMatch[1],
          path: returnMatch[2],
          description: returnMatch[3]
        });
      }
    } else if (trimmed.startsWith('@permissions ')) {
      endpoint.permissions = trimmed.replace('@permissions ', '').trim();
    } else if (trimmed.startsWith('@rateLimit ')) {
      endpoint.rateLimit = trimmed.replace('@rateLimit ', '').trim();
    } else if (trimmed.startsWith('@error ')) {
      finalizeCurrentContent();
      const errorMatch = trimmed.match(/@error (\S+)\s*-\s*(.+)/);
      if (errorMatch) {
        currentError = {
          code: errorMatch[1],
          description: errorMatch[2],
          recover: null
        };
        endpoint.errors.push(currentError);
        recoverLines = [];
      }
    } else if (trimmed.startsWith('@recover ')) {
      recoverLines = [trimmed.replace('@recover ', '').trim()];
    } else if (trimmed.startsWith('@example ')) {
      finalizeCurrentContent();
      currentSection = 'example';
      currentExample = {
        title: trimmed.replace('@example ', '').trim(),
        json: ''
      };
      endpoint.examples.push(currentExample);
      exampleJsonLines = [];
    } else if (trimmed.startsWith('@see ')) {
      const seeMatch = trimmed.match(/@see (\S+)\s*-\s*(.+)/);
      if (seeMatch) {
        endpoint.related.push({
          endpoint: seeMatch[1],
          description: seeMatch[2]
        });
      }
    } else if (trimmed.startsWith('@note ')) {
      endpoint.notes.push(trimmed.replace('@note ', '').trim());
    } else if (trimmed.startsWith('@todo ')) {
      endpoint.notes.push('TODO: ' + trimmed.replace('@todo ', '').trim());
    } else if (trimmed.startsWith('@needs-clarification ')) {
      endpoint.needsClarification.push(trimmed.replace('@needs-clarification ', '').trim());
    } else if (trimmed.startsWith('@')) {
      // Unknown tag
    } else {
      if (currentSection === 'description') {
        descriptionLines.push(trimmed);
      } else if (currentSection === 'param' && sourceLines.length > 0) {
        sourceLines.push(trimmed);
      } else if (currentError && recoverLines.length > 0) {
        recoverLines.push(trimmed);
      } else if (currentSection === 'example' && currentExample) {
        if (trimmed.startsWith('{') || trimmed.startsWith('[') || exampleJsonLines.length > 0) {
          if (!trimmed.startsWith('}') || exampleJsonLines.length === 0) {
            exampleJsonLines.push(trimmed);
          }
          if (trimmed === '}' || trimmed === '},' || trimmed.endsWith('}')) {
            exampleJsonLines.push(trimmed);
          }
        }
      }
    }
  }

  finalizeCurrentContent();
  endpoint.description = descriptionLines.join(' ').trim();
  return endpoint;
}

async function extractEndpointsFromFile(filePath) {
  const content = await readFile(filePath, 'utf-8');
  const endpoints = [];
  const jsdocRegex = /\/\*\*[\s\S]*?@hacs-endpoint[\s\S]*?\*\//g;
  const matches = content.match(jsdocRegex);

  if (matches) {
    for (const match of matches) {
      const endpoint = parseEndpointBlock(match);
      if (endpoint.tool) {
        endpoint.sourceFile = filePath;
        endpoints.push(endpoint);
      }
    }
  }
  return endpoints;
}

async function scanForEndpoints(dir) {
  const endpoints = [];
  try {
    const files = await readdir(dir);
    for (const file of files) {
      if (file.endsWith('.js') && !file.startsWith('_')) {
        const filePath = join(dir, file);
        const fileEndpoints = await extractEndpointsFromFile(filePath);
        endpoints.push(...fileEndpoints);
      }
    }
  } catch (error) {
    console.error(`Error scanning ${dir}:`, error.message);
  }
  return endpoints;
}

// ============================================================================
// GENERATOR (VERBOSE - includes x-hacs-tools)
// ============================================================================

function paramsToSchema(params, includeSource = true) {
  const properties = {};
  const required = [];

  for (const param of params) {
    const prop = {
      type: param.type === 'string' ? 'string' :
            param.type === 'number' ? 'number' :
            param.type === 'boolean' ? 'boolean' :
            param.type === 'array' ? 'array' :
            param.type === 'object' ? 'object' : 'string',
      description: param.description
    };

    // Include Source: in verbose mode
    if (param.source && includeSource) {
      prop.description += `\n\nSource: ${param.source}`;
    }

    if (param.enum) prop.enum = param.enum;
    if (param.default !== undefined) prop.default = param.default;

    properties[param.name] = prop;
    if (param.required) required.push(param.name);
  }

  return {
    type: 'object',
    properties,
    required: required.length > 0 ? required : undefined
  };
}

function generateVerboseSpec(endpoints) {
  const spec = {
    openapi: CONFIG.openapi.version,
    info: CONFIG.openapi.info,
    servers: CONFIG.openapi.servers,
    paths: {
      '/mcp': {
        post: {
          operationId: 'executeMcpFunction',
          summary: 'Execute MCP coordination function',
          description: 'Execute any coordination function through the MCP protocol interface.',
          requestBody: {
            required: true,
            content: {
              'application/json': {
                schema: { $ref: '#/components/schemas/JsonRpcRequest' }
              }
            }
          },
          responses: {
            '200': {
              description: 'Function executed successfully',
              content: {
                'application/json': {
                  schema: { $ref: '#/components/schemas/JsonRpcResponse' }
                }
              }
            }
          }
        }
      },
      '/health': {
        get: {
          operationId: 'getHealth',
          summary: 'Health check',
          security: [],
          responses: { '200': { description: 'Server is healthy' } }
        }
      }
    },
    components: {
      schemas: {
        JsonRpcRequest: {
          type: 'object',
          required: ['jsonrpc', 'method', 'params', 'id'],
          properties: {
            jsonrpc: { type: 'string', const: '2.0' },
            method: { type: 'string', const: 'tools/call' },
            params: { $ref: '#/components/schemas/ToolCallParams' },
            id: { oneOf: [{ type: 'string' }, { type: 'number' }] }
          }
        },
        ToolCallParams: {
          type: 'object',
          required: ['name'],
          properties: {
            name: {
              type: 'string',
              enum: endpoints.map(e => e.tool),
              description: 'Name of the coordination function to execute'
            },
            arguments: {
              type: 'object',
              description: 'Function-specific arguments'
            }
          }
        },
        JsonRpcResponse: {
          type: 'object',
          properties: {
            jsonrpc: { type: 'string', const: '2.0' },
            result: { type: 'object' },
            error: { $ref: '#/components/schemas/JsonRpcError' },
            id: { oneOf: [{ type: 'string' }, { type: 'number' }] }
          }
        },
        JsonRpcError: {
          type: 'object',
          properties: {
            code: { type: 'integer' },
            message: { type: 'string' },
            data: { type: 'object' }
          }
        }
      }
    },
    'x-hacs-tools': {}
  };

  // Add FULL verbose x-hacs-tools entries
  for (const endpoint of endpoints) {
    spec['x-hacs-tools'][endpoint.tool] = {
      name: endpoint.tool,
      description: endpoint.description,
      category: endpoint.category,
      status: endpoint.status,
      version: endpoint.version,
      since: endpoint.since,
      inputSchema: paramsToSchema(endpoint.params, true),
      permissions: endpoint.permissions,
      rateLimit: endpoint.rateLimit,
      errors: endpoint.errors,
      examples: endpoint.examples,
      related: endpoint.related,
      notes: endpoint.notes,
      needsClarification: endpoint.needsClarification.length > 0 ? endpoint.needsClarification : undefined
    };

    spec.components.schemas[`${endpoint.tool}_params`] = paramsToSchema(endpoint.params, true);
  }

  return spec;
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘  HACS OpenAPI VERBOSE Generator                               â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  const args = process.argv.slice(2);
  const outputIndex = args.indexOf('--output');
  const outputPath = outputIndex >= 0 ? args[outputIndex + 1] : CONFIG.defaultOutput;

  // Ensure output directory exists
  const outputDir = dirname(outputPath);
  await mkdir(outputDir, { recursive: true });

  console.log('\nğŸ“‚ Scanning for @hacs-endpoint documentation...');
  let allEndpoints = [];

  for (const dir of CONFIG.scanDirs) {
    console.log(`   Scanning: ${dir}`);
    const endpoints = await scanForEndpoints(dir);
    allEndpoints.push(...endpoints);
  }

  const externalEndpoints = allEndpoints.filter(e => e.visibility !== 'internal');

  console.log(`\nâœ… Found ${externalEndpoints.length} external endpoint(s)`);

  console.log('\nğŸ“ Generating VERBOSE OpenAPI specification...');
  const spec = generateVerboseSpec(externalEndpoints);

  await writeFile(outputPath, JSON.stringify(spec, null, 2));
  console.log(`\nâœ… Verbose OpenAPI spec written to: ${outputPath}`);

  const stats = JSON.stringify(spec).length;
  console.log(`   Size: ${(stats / 1024).toFixed(1)} KB`);
  console.log(`   Tools documented: ${Object.keys(spec['x-hacs-tools']).length}`);
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
}

main().catch(console.error);
