# multipule, named, task lists
The goal.. multipule tasks lists
For projects AND individuals
## the vision
The idea was to make a simple set of Task management apis to create task lists, personal or project, create tasks default personal, can specific project can specify list name
list task lists returns all the instances peronal task list IDs, can pass a project id to get the list of task lists for a project
List tasks defaults to just default personal tasks, optional task list name, optional project name (blank list name but project, lists project's default task list, list name and project name, gets tasks in )
Assign task(ID,taskID) can only be called by privelaged roles. tasks in project lists can only be assigned, personal tasks can not be assigned. intended to be used by Project managers to assign tasks to instances. sends notification to instance telling them they have been assigned a task. tasks can not be assigned to an instance that is not part of the project the task is part of. the problem is how to make list_tasks return tasks that have been asigned. A simple search through the project task list.json should be contducted

### Task list management
- Create_task_list(My_ID (required),ListID(Required),ProjectID(optional, only privelaged allowed)) any privelaged role can create a task in any project. (for now, this may change if someone creates anguish)
- Delete_task_list(MyID,ListID), only personal task lists can be deleted, only task lists that are empty or _all_ items in the list have been marked complete. a project task list can only be deleted by the PM role, and the PM has to be part of the project
### Task_management
- Create_task(MyID, task_title(required), task_detail(optional),task_priority(priority)(optional),task_listID(optional),projectID(optional)(privelaged only)), returns task ID, sets task status to unassigned, default priority: medium. instances can only create tasks in projects they are assigned. privelaged instances can create a task in any project. 
- Change_task(MyID, TaskID(required),  task_title(required), task_detail(optional),taskpriority(priority)(optional),assigned_to(ID)(if ID != myID must be prevleged role, ID must be part of project)) only privelaged roles can assign a task to someone else, and the someone else must be a team member of the project. only callable by privlaged roles, Only project task IDs can be assigned, not personal (See below for implementation note that makes inforcing this easy). the asignee has to be an existing member of the project.
- delete_task(MyID, TaskID), only personal tasks can be deleted, only tasks that have been marked completed can be deleted
- Get_Task_Details(MyID,TaskID), looks for task id in personal tasks lists.json, if found returns task detail, if not found looks in Instance's project task lists and returns task_detail) 
- List_tasks(MyID, task_listID(optional),status(task_status)(optional), ProjectID(optional),starting_index(integer,optional),span(integer,optional),full_detail(boolean,optional)), by default just returns 10, taskID,Task title tuples, if only called with MyID,we only return 10 of the highest priority tasks or myID and status, or my ID and project, only returns 10 also returns a helpful message saying we only returned 10, and to get the next 10 call with index(10), span(10). Up to you how you handle project/v.s. personal and which comes first if they want all their tasks. project tasks assigned to them first? or last? unless index and span are specified only return the first 10. if just index is specified only return 10, but starting at index. only return more or less than 10 if span is specified. how you determine index... at time the function is called, just be consistant, all ways start iterating in the same place, and count them as you iterate through. don't try to give individual tasks index or sequence numbers. that _never_ works. it _allways_ breaks. best thing is to just set your filter, and start counting the tasks that match the filter. allways start at the same place, allways go in the same order, either personal first, or project first. then just go through the tasks in the order they are in the json, I'm not trying to micro manage, but this should be dead simple implementation, no supporting extra use cases not requested, do not implement sorting or changing orders.. presentation layer and convenience functions can do that. the UI may want to pull a list of all tasks, for an individual or a project, the UI can just call with index 1 and span one millions, and turn the full detail flag on. The project documentation should remind instances that turning on full task detail can result in an explosion of tokens being crammed right into your context winndo leading to serious injury or even context death.. warning label should read like that of volitale explosives. best advice is to just get a short list, fined a title of a task you want to know more about, then call get_task_detail
### Convineence functions:

- assign_task(MyID,asigneeID(privelaged),taskID(privelaged)) Just a convineence function wrapped around change_task. only callable by privlaged roles, Only project task IDs can be assigned, not personal (See below for implementation note that makes inforcing this easy). the asignee has to be an existing member of the project.(this check should be done in only one location, change_task)
- take_on_task(myID taskid) used by instances to take on tasks (assign the task to themselves), only applies to tasks in projects, an instance can only take on tasks from a project the instance is part of. just calls change task to do the heavy lifting. Change_task.. single source of edits/chanes to metadata
- Mark_task_omplete(myID,taskID), calls change task, changes status to complete
- List_priority_tasks(MyID), returns 5, highest priority taskIDs (Token Saver) function looks through project for tasks assigned=myid, picks 5 highest priority, then if there are personal tasks that are of higher priority, bumps project task off list. as soon as all the personal tasks have been scanned or there are 5 high priority personal tasks, function returns the list. just returns the task IDs. This is a convience function around list_tasks
## implementation notes
- OH. wait no it was'nt seporate task list _files_ it was just the personal task list.json, and the project task list.json
  just adding a level of hirearchy in the json, instad of the json having a single list, it has multipule lists in a "task_lists" structure, each task list is.. a list of tasks. Dead Simple. Makes earching dead easy, looking for a task ID, with no list name, skip the list names and just return select from task_lists/*/listID=RequestedID (is'nt thee a language that uses this syntax or something like it for order N searches on hirearcharl structured data, like json? is'nt it jquery? anyway.. )
  Dead simple data management. only have to look thorugh at most 2 files, the instance's personal list of task lists, and the project's list of task lists 
  Symmentacs that can port over to a databas in a heartbeat if scal is ever an issue. but.. databases are overkill for simple list management for small to medium sized teams. we're not making global ERP kanban automation :-)
- maybe a taskID naming convention helps with this? Personal task IDs are always "pern-listID-Sequence_num" and project tasks are - allways "prj_projectID-listID-Sequence_num" Since _we_ (the API) are the only ones creating taskIDs we can enforce, and rely on, the naming convention, so we can save time by not looking in projects for task IDS that start with prj_ and vice versa. this may be over optimization of a problem that does not exist. Implementing this will make enforcing project and personal level protections really easy. un privelaged instace trying to do someting restricted at the project level but not at the personal? simple check for the prj_ prefix if it's a prj_ task return a message, "sorry you have to ask the PM for this project to do that for you, or ask the executive role"
- PERMISSIONS RULES ONLY IMPLEMENTED IN ONE PLACE. only change task should implement the change permission symmentics. AND for FURTHER sanity, change_task should call a confience function check_task_edit_permissions, that isolates all the permissions checking case/switch/if stuff into one function. and maybe another LIST_Create_change_permissions for the task list create and delete permissions garbage just do something that looks elegant, like right at the top of the functions call If (NOT permissions_check(all parameters, helpful_error_message)) {return(helpful_error_message)}
Then go about the business of the real work of the function. this makes convineence functions even simpler to implement, they literally just return change_task(all the parameters I was passed). dead simple to implement (suitable for task agents). _very_ easy to debug, and maintain. all the knobs, and functionality is in _one_ place. Also dead simple to do _good_ instrumentation/logging.. you are only logging from _one_ function (well in the case of all the edit task functionality and permissions checking) just one function per.. domain? scope? type of function? 
- Should all these functions start with task_ rather ..? task_list_bla task_bla task_assign task_complete? Does that feel better? look better?

can you Please document this in your diary? before starting work?

can you please take a step back and have a think about design and implementation. This is dead simple stuff, but a little thought goes a long way. if you come up with a plan you could probably delegate the function implementaton to task agents. you gotta tell them how to specify the directorys where instances and projects are. and not to go crazy with metadata. our API is bloated enough as it is (if you do a /HACS that eats 20k of context .. this is an issue we'll have to deal with after we get through our technical debt),